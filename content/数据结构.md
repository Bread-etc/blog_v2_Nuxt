# 数据结构

博客搭建得差不多了，准备增加一点内容来丰富我的博客，想来想去觉得`数据结构`作为开头比较合适用来镇场子🤓使用较熟悉的`JavaScript`或者`cpp`来展示。【本文参考多为网络上资源以及《JavaScript高级程序设计 (第四版)》】
## 数组
 `JavaScript`内的数组和其他编程语言的数组有很大的区别，数组内的每个槽位都可以存储任意类型的数据，里面可以是对象(Object)、字符串(String)、数值(Number)。另外，值得一提的是，数组是动态大小的，会随着数据添加而自动增长。
### 创建数组
创建数组的方法有很多，一般是使用`Array`构造函数，例如`let newArr = new Array();`。有的时候，我们也可以省略`new`操作符，结果都是一样的。但是里面有些新特性：`from()`和`of()`两个方法，前者用于将`类数组结构`转换为数组实例，而后者用于将一组参数转换为数组实例。听起来确实比较空，我们举两个例子🌰：
```javascript
// 字符串被拆分成了单字符串的数组
console.log(Array.from("joker"));  // ["j", "o", "k", "e", "r"]

// 使用from()将集合和映射转换为一个新数组
const m = new Map().set(1, 2).set(3, 4);  // [[1, 2], [3, 4]]
const s = new Set().add(1).add(3);  // [1, 3]

// Array.of()代替了ES6之前常用的Array.prototype.slice.call(arguments)
console.log(Array.of(1, 2, 3, 4));  // [1, 2, 3, 4]
console.log(Array.of(undefined));  // [undefined]
```
> 在红宝书的`6.2.1`章节中还有更多关于from()和of()的内容，此处就不一一叙述。
### 数组的索引
数组的索引在很多编程语言都十分常见，JavaScript也不例外，数组的索引(index)一般都是从0开始，然后随着元素的个数逐渐递增。其中数组的`length`属性的独特之处在于，它不是只读的，我们可以通过修改`length`属性，实现从数组末尾添加➕或者删除➖元素。
```javascript
// 删除
let colors = ['red', 'blue', 'green'];  // 三原色
colors.length = 2;
console.log(colors[2]);  // undefined

// 添加
let colors = ['red', 'blue', 'green'];
colors.length = 4;
console.log(colors[3]);  // undefined
// 或者添加其他值
colors[colors.length] = "white";  // 将白色添加到了数组的最后一项
```
### 迭代器方法
在ES6中，`Array`的原型上暴露了 3 个用于检索数组内容的方法：`keys() / values() / entries()`。`keys()`返回数组索引的迭代器，`values()`返回数组元素的迭代器，而 `entries()`返回 索引/值对的迭代器：
```javascript
const a = ["foo", "bar", "baz", "qux"]; 

const aKeys = Array.from(a.keys());  // [0, 1, 2, 3]
const aValues = Array.from(a.values());  // [ 'foo', 'bar', 'baz', 'qux' ]
const aEntries = Array.from(a.entries());  // [[0, "foo"], [1, "bar"], [2, "baz"], [3, "qux"]]
```
### 栈方法
栈(stack)是一种后进先出(LIFO, Last-In-First-Out)的结构，就像口袋一样，最后放进去的东西会被最先拿出来，而最开始放入的东西在最后才能拿出来。ECMAScript数组提供了`push()`和`pop()`方法来实现类似栈的行为。
`push()`方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度。而`pop()`方法用于删除数组的最后一项，返回被删除的项。
```js
let colors = new Array();
let count = colors.push("red", "green");
alert(count);  // 返回 2

count.push("blue");
alert(count);  // 返回 3

let item = colors.pop();
alert(item);  // 返回 “blue”
alert(colors.length()); // 返回 2
```
### 队列方法
队列(list)是以先进先出(FIFO, First-In-First-Out)的形式限制访问。队列在列表的末尾添加数据，但是从列表的开头获取数据，类似上面提到的口袋👛，但是口袋破了一个洞，第一个放入的东西就会第一个掉出来。与上面类似，在数据末尾添加数据的方法是`push()`，而从数组开头得到数据的方法是`shift()`，配合两者来使用，可以把数组当成队列来使用。
```js
let colors = new Array();
let count = colors.push("read", "write");
alert(count);  // 返回 2

count.push("listen");  // 返回 3

let item = colors.shift();
alert(item);  // read
alert(colors.length)  // 返回 2
```
>除此以外，数组也有`unshift()`方法，其执行操作和`shift()`相反，就是在数组的开头添加任意多个值，然后返回新的数组的长度。
### 排序方法
数组一般使用两种方法来对元素重新排序：`reverse()`和`sort()`。前者就是简单地将数组元素反向排列，虽然直观，但远不如后者灵活。
默认情况下，`sort()`会按照升序(从小到大)重新排列数组元素。因此，该方法会在数组的每一项上都调用`String()`转型函数，然后用于比较字符串决定顺序。
```js
let values = [0, 1, 5, 10, 15];
values.sort();
alert(values);  // [0, 1, 10, 15, 5]
```
为了解决上面这种尴尬的情况，`sort()`方法可以接受一个**比较函数** ，用于判断哪个值应该排在前面。比较函数接受两个参数，如果第一个参数应该排在第二个参数前面，就返回负值；相等就返回零；排在后面就返回正值。以下是一个例子🌰：
```js
function compare(value1, value2) {
	if(value1 < value2) {
		return -1;
	} else if(value1 > value2) {
		return 1;
	} else {
		return 0;
	}
}

let values = [0, 1, 5, 10, 15];
values.sort(compare);
alert(values);  // 0, 1, 5, 10, 15
```
如果把上面的函数的正负值对调一下，再调用`sort(compare)`方法，就可以得到`15, 10, 5, 1, 0`从大到小排序的数组。在红宝书中，由于函数较为简单，此处可以利用三元表达式来写成一个箭头函数➡：
```js
values.sort((a, b) => a < b ? 1 : a > b ? -1 : 0);  // 降序， 默认情况是升序
alert(values);  // 15, 10, 5, 1, 0
```
参考掘金上的其他文章，也有以下写法：
```js
let arr = [0, 1, 5, 15, 45];
arr.sort((a, b) => (a-b));  // 升序
arr.sort((a, b) => (b-a));  // 降序
```
>**注意❗**：`reverse()`和`sort()`函数都返回它们的数组的引用，会改变原来数组的值，因此如果有同时实现升序和降序的需求，应该使用中间变量。
### 操作方法
最强大的数组方法就属`splice()`了，拥有多种使用方式。主要目的是在数组中间插入元素，但是有 3 种不同的方法使用：
- **删除**：给`splice()`传入两个参数：要删除的第一个元素的位置和要删除的元素数量。可以从数组中删除任意多个元素，例如`splice(0, 2)`会删除前两个元素。
- **插入**：给`splice()`传入三个参数：开始位置、0（要删除的元素数量）、要插入的元素。例如`splice(2, 0, "red", "green")`会从数组位置 2 开始插入这两个字符串。
- **替换**： 给`splice()`传入三个参数：开始位置、要删除的元素数量、替换的元素。例如`splice(2, 2, "red", "green")`会从位置 2 开始删除两个元素，然后用`"red"/ "green"`替换。
> **注意⚠**：以上提到的 7 种处理数组的方法，都会改变原来的数组的内容，如果需要保留原数组的内容，请使用下面提到的方法。

方法`join()`用于把数组中的所有元素转换为一个字符串，元素可以通过方法内只能得分隔符进行分隔。
```js
const items = ["Matt", "Nicolas", "Jody"];

console.log(items.join());  // "Matt,Nicolas,Jody"
console.log(items.join(''));  // "MattNicolasJody"
console.log(items.join('-'));  // "Matt-Nicola-Jody"
```

方法`slice()`用于创建一个包含原有数组中一个或多个元素的新数组，且可以接受一个或两个参数：返回元素的开始索引和结束索引。如果只有一个参数，则`slice()`会返回该索引到数组末尾的所有元素；两个参数则返回从开始索引到结束索引对应的所有元素，其中不包括结束索引对应的元素。
```js
let colors = ["red", "green", "blue", "yellow", "purple"];
let colors2 = colors.slice(1);
let colors3 = colors.slice(1, 4);

alert(colors2);  // green, blue, yellow, purple
alert(colors3);  // green, blue, yellow
```
>**注意**： 如果`slice()`的参数有负值，那么就以数值长度加上这个负值的结果确定位置。比如`slice(-2, -1)`，在上述的例子中就相当于调用`slice(3, 4)`

`concat()`方法可以在现有数组全部元素的基础上创建一个新数组，把参数添加到新副本的末尾，再返回新副本。【感觉有点类似高级版的`push()`和Linux内的`cat`命令】
```js
let colors = ["red", "green", "blue"];
let colors2 = colors.concat("yellow", ["black", "brown"]);

console.log(colors);  // ["red", "green", "blue"]
console.log(colors2);  // ["red", "green", "blue", "yellow", "black", "brown"]
```
>值得一提的是，使用`Symbol.isConcat-Spreadable`，这个值设置为`true`可以强制打平类数组对象，如果你希望保持类数组结果的话，请将这个值设置为`false`。
### 搜索和位置方法
有两类搜索数组的方法：按严格相等搜索和按断言函数搜索。
1. 严格相等
ECMAScript提供了 3 个严格相等的搜索方法：`indexOf()` / `lastIndexOf()` / `includes()`。其中前两个方法在所有版本都可用，第三个方法在ES7新增的。这些方法都接收两个参数：要查找的元素和一个可选的起始搜索位置。`lastIndexOf()`与另外两个方法不同，是从后向前搜索。
  前两个方法都返回要查找的元素在数组中的位置，如果没有找到就返回 -1 。而`includes()`返回布尔值，表示是否找到至少一个与指定元素匹配的项。【在比较第一个参数跟数组的每一项时，会使用全等`===`进行比较】
```js
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];

alert(numbers.indexOf(4));  // 3
alert(numbers.lastIndexOf(4));  // 5
alert(numbers.includes(4));  // true

alert(numbers.index(4, 4));  // 5
alert(numbers.lastIndexOf(4, 4));  // 3
alert(numbers.includes(4, 7));  // false
```
2. 断言函数
断言函数接收 3 个参数：元素、索引、数组本身。其中元素是数组中当前搜索的元素，索引是当前元素的索引，而数组就是正在搜索的数组。断言函数返回真值，表示是否匹配。其中`find()`和`findIndex()`使用了断言函数。这两个方法都从数组的最小索引开始。前者返回第一个匹配的元素，后者返回第一个匹配元素的索引。这两个方法也都接收第二个可选的参数，用于指定断言函数内部`this`的值。
```js
const people = [{ name: "Matt", age: 29 }, { name: "Niko", age: 26 }];

alert(people.find((element, index, array) => element.age < 28));
// { name: "Niko", age: 26 }

alert(people.findIndex((element, index, array) => element.age > 28));
// 0
```
> 当找到匹配后，该方法不会再向后检查其他元素。
### 迭代方法
数组有 5 个迭代方法。每个方法接收两个参数：以每一项为参数运行的函数，以及可选的作为函数运行上下文的作用域对象（影响函数中`this`的值）。传给每个方法的函数接收 3 个参数：数组元素(element)、元素索引(index)和数组本身(array)。5 个迭代方法如下：
- `every()`：对数组的每一项都运行传入的函数，如果对每一项函数都返回`true`，则这个方法返回`true`
- `filter()`： 对数组的每一项都运行传入的函数，函数返回`true`的项会组成数组之后返回。
- `forEach()`： 对数组每一项都运行传入的函数，没有返回值
- `map()`：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组
- `some()`：对数组每一项都运行传入的函数，如果有一项函数返回`true`，则这个方法返回`true`。这些方法都不改变调用它们的数组。
其中`every()`和`some()`方法最为类似，都是从数组中搜索符合某个条件的元素，但是前者必须每一项都返回`true`才会返回`true`；而后者只需要有一项的函数返回`true`，它就会返回`true`。
```js
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];

let everyResult = numbers.every((item, index, array) => item > 2);
alert(everyResult);  // false

let someResult = numbers.some((item, index, array) => item > 2);
alert(someResult);  // true
```
再看看`filter()`方法，这个方法基于给定的函数来决定某一项是否应该包含在它返回的数组中。比如，要返回一个所有数值都大于 2 的数组，可以使用如下代码：
```js
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];

let filterResult = numbers.filter((item, index, array) => item > 2);
alert(filterResult);  // 3, 4, 5, 4, 3
```
我们可以把`filter()`理解为一个漏斗⌛︎，只通过我需要的元素，不需要的元素则抛弃。
另外，`map()`方法也会返回一个数组。这个数组的每一项都是对原始数组中同样位置的元素运行传入函数而返回的结果。例如，可以将一个数组中的每一项都乘以 2 ，并返回包含所有结果的数组，如下所示：
```js
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];

let mapResult = numbers.map((item, index, array) => item * 2);
alert(mapResult);  // 2, 4, 6, 8, 10, 8, 6, 4, 2
```
很多时候，我们并不需要调用数组的索引和数组本身，我们可以简写成以下形式：
```js
let mapResultSimple = numbers.map(item => item * 2);
alert(mapResultSimple);  // 2, 4, 6, 8, 10, 8, 6, 4, 2
```
目光放到`forEach()`方法，这个方法只会对每一项运行传入的函数，没有返回值。本质上和 for 循环没啥太大的区别。。。
```js
forEach((item, index, array) => {
	item ** 2;
})  // 如果返回该值的话只会返回 undefined
```
> map() 方法返回值，而 forEach() 方法不返回值。
### 归并方法
第一次听到**归并**这个词还是挺陌生的，这里解释一下：归并，就是将已经分散的数据合并起来。JS内有两个归并方法：`reduce()`和`reduceRight()`。这两个方法都会迭代数组的所有项，并在此基础上构建一个最终返回值。`reduce()`方法从数组第一项开始遍历到最后一项，而`reduceRight()`与其相反。
这两个方法都接收两个参数：对每一项都会运行的归并函数，以及可选的以之为归并起点的初始值。传给`reduce()`和`reduceRight()`的函数接收 4 个参数：上一个归并值、当前项、当前项的索引和数组本身。这个函数的返回的任何值都会作为下一次调用同一个函数的第一个参数。如果没有传入可选的第二个参数（作为归并起点值），则第一次迭代将从数组的第二项开始，因此传给归并函数的第一个参数是数组的第一项，第二个参数是数组的第二项。这听起来确实很抽象绕口，以下我们举两个例子🌰：
```js
let values = [1, 2, 3, 4, 5];
let sum = values.reduce((prev, cur, index, array) => prev + cur);
let sumRight = values.reduce((prev, cur, index, array) => prev + cur);

alert(sum);  // 15 (1+2+3+4+5)
alert(sumRight);  // 15 (5+4+3+2+1)
```
## Map
由于前面的代码有提到`new Map()`和`new Set()`，我觉得有必要在这里提一下。Map 是 ES6 新增的特性，作为一种新的集合类型，为这门语言带来的真正的 键/值 存储机制。Map 的大多数特性都可以通过 Object 类型实现，但是二者还是存在一些细微的差异。
### 基本 API
使用`new`关键字和`Map`构造函数就可以创建一个空映射：`const m = new Map()`。初始化后，可以使用`set()`方法再添加键值对。另外可以使用`get()`和`has()`进行查询，可以通过 size 属性获取映射中键值对的数量，还可以使用`delete()`和`clear()`删除值。
```js
const m = new Map();

alert(m.has("firstName"));  // false
alert(m.get("firstName"));  // undefined
alert(m.size);  // 0

m.set("firstName", "Jody").set("lastName", "brown");

alert(m.has("firstName"));  // true
alert(m.get("firstName"));  // Jody
alert(m.size);  // 2

m.delete("firstName");

alert(m.has("firstName"));  // false
alert(m.has("lastName"));  // true
alert(m.size);  // 1

m.clear();  // 清除映射实例中的所有键值对
```
与`Object`只能使用数值、字符串或符号作为键不同，`Map`可以使用任何 JavaScript数据类型作为键，`Map`内部使用 SameValueZero 比较操作，基本上相当于使用严格对象相等的标准来检查键的匹配性。和对象类似，映射的值是没有限制的。
### 顺序与迭代
与 `Object` 类型的一个主要差异是，`Map`实例会维护键值对的插入顺序，因此可以根据插入顺序执行迭代操作。
映射实例可以提供一个迭代器（Iterator），能以插入顺序生成键值对形式的数组，可以通过`entries()`方法（或者 Symbol.iterator 属性，它引用`entries()`）取得这个迭代器：
```js
const m = new Map([
	["key1", "value1"],
	["key2", "value2"],
	["key3", "value3"]
]);

alert(m.entries === m[Symbol.iterator()]);  // true

for (let pair of m.entries()) {
	alert(pair);
}
// [key1, value1]
// [key2, value2]
// [key3. value3]
for (let pair of m[Symbol.iterator]()) {
	alert(pair);
}
// [key1, value1]
// [key2, value2]
// [key3. value3]
```
由于`entries()`是默认迭代器，所以可以直接对映射实例使用扩展操作，把映射转换为数组：
```js
const m = new Map([
	["key1", "val1"],
	["key2", "val2"],
	["key3", "val3"]
]);
console.log([...m]); // [[key1,val1],[key2,val2],[key3,val3]]
```
另外，map实例也有`keys()`和`values()`方法返回键和值，这里就不一一解释。
> 不同浏览器的情况不同，但在固定大小的内存中，`Map`大约可以比`Object`多存储 50% 的键值对。且插入`Map`在浏览器会稍微快一点，如果涉及大量插入操作，选择 Map 会更好。如果涉及大量查找，`Object`会好一些。但是性能逐渐发展的今天，如果是用于个人项目，两者的性能差距几乎可以忽略不计了。
## Set
`Set`在很多方面都像是加强版的`Map`，这是因为它们的大多数 API 和行为都是共有的。
### 基本 API
和`Map`相同，相同的关键字`new`和`has() / size / delete() / clear()`等方法就不再赘述。另外，`Set`初始化之后，可以使用`add()`增加值：
```js
const s = new Set();

s.add("Matt").add("Niko");

alert(s.has("Matt"));  // true
alert(s.size);  // 2

s.clear();
alert(s.has("Niko"));  // false
alert(s.size);  // 0
```
与`Map`类似，`Set`可以包含任何 JavaScript 数据类型作为值。集合也使用 SameValueZero 操作，基本上相当于使用严格对象相等的标准来检查值的匹配性。
> 与 Python 的元组类似，集合里面的元素和高中数学内传统的集合是一样的：即里面不能存在相同的值。
### 顺序与迭代
集合实例提供一个迭代器，能以插入顺序生成集合内容，可以通过`values()`和别名方法`keys()`（或者 Symbol.iterator 属性，它引用`values()`取得这个迭代器）。【此处几乎和Map没有什么区别，就不一一展示代码了🖍，详情可以查阅红宝书的`6.6.2`章节】
## 链表
链表结构是内存内部的一种存储方式，链表是把一系列节点(node)串联起来，每个节点至少包含两个部分：`数据域`与`指针域`。每个节点通过指针域的值，形成一个线性结构。
[![linked-list.png](https://www.freeimg.cn/i/2024/03/11/65eec12e387ad.png)](https://www.freeimg.cn/i/2024/03/11/65eec12e387ad.png)链表可以分为三类：
- 单向链表：线性数据结构，指针指向下一个结点，终点指向null
- 双向链表：可以往前或往后添加节点，指针指向前一个节后和后一个节点
- 循环链表：循环链表的第一个节点指向最后一个节点，最后一个节点指向第一个节点【又可细分为“单向循环链表”和“双向循环链表”】
### 单向链表
我们先写一个简单的节点的**类**：
```js
class Node {
	constructor(value) {
		this.value = value;
		this.next = null;
	}
}
```
然后再创建链表，其中链表包含一个`head`指针，`size`表示链表的节点的个数：
```js
class LinkedList {
	constructor() {
		this.head = null;
		this.size = 0;
	}
}
```
从上面的图片可以看到，节点的插入和删除操作无非就是**操作指针的指向**。以下会新增几个对链表进行操作的方法。【LinkedList类的方法】
`add(value)`**往链表新增节点：**
```js
add(value) {
	const node = new Node(value);  // 新增节点
	let curr;  // 当前节点
	if (this.head === null) {
		// 如果是空链表的话，将空链表的头指针head指向节点
		this.head = node;
	} else {
		// 非空，curr初始化为链表的头节点 this.head
		curr = this.head;
		while(curr.next) {  // 当下一节点不为空的时候，继续指向下一节点
			curr = curr.next;
		}
		curr.next = node;
	}
	this.size++;
}
```
`insert(index, value)`**指定位置插入节点：**
```js
insert(index, value) {
	if (index < 0 || index > this.size - 1) {
		return false;  // 插入操作无效
	} else {
		const node = new Node(value);
		let prev, curr = this.head;  // 记录前一个节点和当前节点

		// 头部插入
		if (index === 0) {
			node.next = curr;  // 直接将新节点插入到头部，并将新节点的 next 指针指向当前头节点 curr
		} else {
			// 非头部插入，从前往后查找到节点，然后改变指针的指向
			while(index > 0) {
				prev = curr;
				curr = curr.next;
				index--;
			}
			prev.next = node;
			node.next = curr;
		}
		this.size++;  // 增加链表的大小
	}
}
```
`removeByIndex(index)`**指定位置删除节点：**
```js
removeByIndex(index) {
	if(index < 0 || index > this.size - 1) {
		return;  // 删除操作无效
	}
	let prev, curr = this.head;  // 初始化记录前一个节点和当前节点
	if (index === 0) {
		this.head = curr.next;  // 移除头节点，指向下一个节点
	} else {
		// 遍历获取指定下标的节点（寻找指定节点）
		while(index > 0) {
			prev = curr;
			curr = curr.next;
			index--;
		}
		// 找到指定节点就前后相连
		prev.next = curr.next;
	}
	this.size--;
	return curr.value;  // 返回被删除节点的值
}
```
`indexOf(value)`**查找目标值的节点下标：**
```js
indexOf(value) {
	let index = 0;  // 初始化索引 index = 0
	let curr = this.head;  // curr 初始化为链表的头节点
	while(curr) {
		if (curr.value === value) {
			return index;
		}
		curr = curr.next;  // 指向下一个节点
		index++;
	}
	return -1;  // 没有找到目标
}
```
`removeByValue(value)`**指定值删除节点：**
```js
removeByValue(value) {
	const index = this.indexOf(value);
	return this.removeByIndex(index);
}
```
`pop()`**弹出最后一个节点：**
```js
pop() {
	let prev, curr = this.head; // 初始化两个变量记录前一个节点和当前节点
	// 如果链表为空的话，直接返回 null
	if (this.size === 0) return null;
	if (!curr.next) {
		// 只有一个节点的情况
		this.head = null;  // 移除了唯一一个节点
	} else {
		while(curr.next) {
			prev = curr;
			curr = curr.next;
		}
		prev.next = null;  // 移除最后一个节点
	}
	this.size--;
}
```
`isEmpty()`**判断是否为空：**
```js
isEmpty() {
	return this.size === 0;
}
```
`print()`**打印链表：**
```js
print() {
	const arr = [];  // 初始化空数组
	let curr = this.head;  // 获取当前节点
	while(curr) {
		arr.push(curr.value);  // 压入当前节点的值到数组中
		curr = curr.next;  // 向后更改节点
	}
	console.log(arr.join('->'));  // 使用 -> 分隔
}
```
> 感谢[数据结构-链表（javascript版） - Kelen](https://www.kelen.cc/posts/javascript-linked-list#google_vignette)提供的资料，另外提一嘴，这个博客做得也挺好看。
### 双向链表
双向链表指的是每个数据节点都有两个指针，分别指向直接后继和直接前驱。特点在于，使用`head`和`tail`分别指向头部和尾部的节点，第一个节点的`prev`是null，最后一个节点的`next`是null。
现在我们来简单地封装下一个双向链表⬅➡：
```js
class Node {
	constructor(value) {
		this.value = value;  // 当前节点的值
		this.next = null;  // 下一个节点的值
		this.prev = null;  // 上一个节点的值
	}
}
```
另外，链表的构造也和单向链表相似：
```js
class LinkedList {
	constructor() {
		this.head = null;  // 头节点
		this.tail = null;  // 尾节点
		this.size = 0;  // 长度
	}
}
```
双向链表的添加新元素的方法和单向链表相似，但是需要设置新节点的`prev`属性，使其指向该节点的前驱。`add(value)`**往链表新增节点：**
```js
add(value) {
	const node = new Node(value);  // 新增节点
	if (this.head === null) {
		// 如果是空链表的话，将空链表的头指针head和尾指针tail指向节点
		this.head = node;
		this.tail = node;
		node.prev = null;
	} else {
		// 非空链表，尾节点插入新的节点node
		this.tail.next = node;  // 尾 -> newNode
		node.prev = this.tail;  // newNode <- tail
		this.tail = node;  // tail -> newNode
	}
	this.size++;
}
```
`insert(value)`**指定位置插入节点**：
```js
insert(index, value) {
	if (index < 0 || index > this.size -1) {
		return false;  // 越界判断，插入操作无效
	} else {
		const node = new Node(value);  // 创建新节点
		
		if (this.size === null) {
			// 判断链表是否为空
			this.head = node;
			this.tail = node;
		} else {
			if (index === 0) {
				// 头部插入
				this.head.prev = node;  // head指针前一个节点 -> node
				node.next = this.head;  // node插入后后一个节点 -> head
				this.head = node;  // 头指针head指向node
			} else if (index === this.size) {
				// 尾部插入
				node.prev = this.tail;  // node的prev设置为tail
				this.tail.next = node;  // 插入尾节点为tail的next
				this.tail = node;  // 尾指针tail指向node
			} else {
				// 除了头插入和尾插入的其他情况 （从头节点开始遍历）
				let curr = this.head;
				let prev = null;
				let i = 0;
				while (i < index) {
					prev = curr;
					curr = curr.next;
					i++;
				}
				node.prev = prev;  // node.prev -> prev
				prev.next = node;  // prev -> node
				node.next = curr;  // node -> curr
				curr.prev = node;  // curr.prev -> node
			}
		}
		this.size++;
		return true;
	}
}
```
`removeByIndex(index)`**指定位置删除节点**：
```js
removeByIndex(index) {
	if (index < 0 || index > this.size - 1) {
		return false;  // 删除操作无效
	} else {
		if (this.size === 1) {
			// 判断链表长度是否为 1
			this.head = null;
			this.tail = null;
		} else {
			if (index === 0) {
				// 删除第一个节点，头指针head往下指
				this.head = this.head.next;
				this.head.prev = null;
			} else if (index === this.size - 1) {
				// 删除最后一个节点，尾指针tail往前指
				this.tail = this.tail.prev;
				this.tail.next = null;
			} else {
				let curr = this.head;
				let prev = null;
				let i = 0;
				while (i < index) {
					prev = curr;
					curr = curr.next;
					i++;
				}
				// 找到指定节点后(越过中间删除的节点)
				curr.prev.next = curr.next;
				curr.next.prev = curr.prev;
			}
		}
	this.size--;
	return true;
	}
}
```
`indexOf(value)`**查找目标值的节点下标**：（和单向链表相似）
```js
indexOf(value) {
	let index = 0;  // 初始化索引 index = 0
	let curr = this.head;
	while (curr) {
		if (curr.value === value) {
			return index;
		}
		curr = curr.next;
		index++;
	}
	return -1;  // 没有找到指定目标
}
```
`removeByValue(value)`**指定值删除节点**：（与单向链表相似）
```js
removeByValue(value) {
	const index = this.indexOf(value);
	return this.removeByIndex(index);
}
```
`get(index)`**获取对应位置的元素**：
```js
get(index) {
	if (index < 0 || index > this.size - 1) {
		return null;  // 操作无效
	}
	let curr = this.head;
	let i = 0;
	while (i < index) {
		curr = curr.next;
		i++;
	}
	return curr.value;
}
```
`update(index, value)`**更新某个元素**：
```js
update(index, value) {
	if (index < 0 || index > this.size - 1){
		return false;  // 更新操作无效
	}
	let curr = this.head;
	let i = 0;
	while (i < index) {
		curr = curr.next;
	}
	curr.value = value;
	return true;
}
```
`print()`**打印链表**：
```js
print() {
	const arr = [];
	let curr = this.head;
	while (curr) {
		arr.push(curr.value);
		curr = curr.next;
	}
	console.log(arr.join('->'));
}
```
## 队列 (queue)
队列是一种遵循先入先出（FIFO）规则的数据结构，队列有两个指针：队首和队尾。最先进入队列进行排队的项目位于**队首**，而最后进入队列的项目位于**队尾**。
[![queue.png](https://www.freeimg.cn/i/2024/03/24/660014652ae51.png)](https://www.freeimg.cn/i/2024/03/24/660014652ae51.png)接下来用`JavaScript`来实现一个简单的队列（queue）：
```js
class Queue {
	constructor() {
		this.items = {};
		this.headIndex = 0;
		this.tailIndex = 0;
	}
}
```
`enqueue(item)`**入队操作：**
```js
enqueue(item) {
	this.items[this.tailIndex] = item;
	this.tailIndex++;
}
```
`dequeue(item)`**出队操作：**
```js
dequeue() {
	const item = this.items[this.headIndex];
	delete this.items[this.headIndex];
	this.headIndex++;
	return item;
}
```
`peek()`**只读队首项**：
```js
peek() {
	return this.items[this.headIndex];
}
```
`getLength()`**获取队列长度**：
```js
getLength() {
	return this.tailIndex - this.headIndex;
}
```
以上的案例是从尾部`tailIndex`开始插入数据，数据从`headIndex`处出来，所以出队操作并不需要传入参数`item`，只需要传出已插入的对象即可。
>另外，可以使用数组来模拟队列`queue`的操作，使用到`push()/shift()/unshift()`等方法。
## 栈 (Stack)
栈是一种遵循**后进先出**（LIFO）规则的有序集合。新添加的或者待删除的元素都保存在栈的尾部（即栈顶），另一端叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。【类似袜子或者口袋，最先放入的最后出来】[![stack.png](https://www.freeimg.cn/i/2024/03/26/660262589d3b7.png)](https://www.freeimg.cn/i/2024/03/26/660262589d3b7.png)接下来使用`JavaScript`实现一个简单的栈（Stack）：
```js
class Stack {
	constructor() {
		this.items = {};
		this.top = 0;  // 从栈底开始向上，指向栈顶的元素
	}
} 
```
再写一些常规的操作`push()/pop()/peek()/getSize()/reset()/isEmpty()/print()`
```js
push(item) {
	this.items[this.top] = item;
	this.top++;
}

pop() {
	const item = this.items[this.top - 1];
    delete this.items[this.top];
    this.top--;
    return item;
}

peek() {
    return this.items[this.top - 1];
} 

getSize() {
    return this.top + 1;
} 

reset() {
	this.items = {};
}

isEmpty() {
    return this.top === 0;
}

print() {
    const arr = [];
    let curr = this.top;
    while (curr > 0) {
      arr.push(this.items[curr - 1]);
      curr--;
    }
    console.log(arr.join('->'));
}
```
>其实，栈和队列类似，也可以使用数组 Array 来实现，且数组有原生的`push/pop/shift/unshift/.length`等方法，实现起来会比`items = {}`要方便许多。
## 堆 （Heap）
堆是一颗**完全二叉树**（complete binary tree）。堆是二叉树的一种，满足以下条件：
- 任意节点大于或小于它的所有子节点（大根堆、小根堆）
- 总是一完全树，即除了最底层，其它层的节点都被元素填满
根据根节点的大小，将根节点最大的堆称为`最大堆`，根节点最小的堆称为`最小堆`。
[![binary_heap.jpg](https://www.freeimg.cn/i/2024/03/26/6602739528924.jpg)](https://www.freeimg.cn/i/2024/03/26/6602739528924.jpg
我们先构建一个简单的以0为根节点的最小堆`MinHeap`：
```js
class MinHeap {
	// 默认为最小堆，如果需要最大堆需要输入(x, y) => y - x
	constructor(compareFunc = (x,y) => x - y, heap = []) {
		this.heap = heap;
		this.size = heap.length;
		this.compare = compareFunc;
		this.buildHeap();
	}

	// 比较两个节点大小
	compareItems(a, b) {
		return this.compare(a, b) > 0;
	}

	// 建堆操作 (从下向上建堆)
	buildHeap(heap) {
		for (let i = 0; i < heap.length; i++) {
			this.insert(heap[i]);
		}
	}

	// 建堆操作 (从上向下建堆)
	buildHeap(heap) {
		// 从最后一个非叶子结点开始，向下heapifyDown
		for (let i = Math.floor(this.size / 2) - 1; i >= 0; i--) {
			this.heapifyDown(i);
		}
	}
}
```
### 堆的操作[0-based]
> 其中`this.size`为当前堆的结点总数，时间复杂度均为o(logn)

获得父节点、左侧子节点、右侧子节点：
```js
leftChild(pos) {
	return 2 * pos + 1;
	// 若为1-based的话则为2 * pos
}
rightChild(pos) {
	return 2 * pos + 2;
	// 若为1-based的话则为2 * pos + 1
}
parent(pos) {
	return Math.floor((pos - 1) / 2);
	// 若为1-based的话则为 pos / 2
}
```
判断是否为叶子结点（没有子节点的节点）：
```js
isLeaf(pos) {
	return pos >= Math.floor(this.size / 2) && pos < this.size;
}
```
上浮操作`heapifyUp`:
首先需要分开两种情况来比较大小：
- 小顶堆：a > b, true 前大于后
- 小顶堆：a < b, true 前小于后
```js
heapifyUp(pos) {
	let parent = this.parent(pos);  // 获取pos的父节点下标
	// pos 还没到顶 && pos的父节点值大于小顶或小于大顶pos值时，pos与父节点交换
	while (pos && this.compareItems(this.heap[parent], this.heap[pos])) {
		[this.heap[pos], this.heap[parent]] = [this.heap[parent], this.heap[pos]];
		pos = parent;
		// 获得交换后pos的新父节点
		parent = this.parent(pos);
	}
}
```
> 直到pos节点上浮到了根节点的位置或pos的父节点小于pos自身的值（最小堆）

下沉操作`heapifyDown`:
```js
heapifyDown(pos) {
	if (this.isLeaf(pos)) return;
	let left = this.leftChild(pos);
	let right = this.rightChile(pos);
	let tmp = 0;
	while (!this.isLeaf(pos)) {
		// 确定左右子节点之间的大小关系，进而确定pos更有可能移动到哪边
		// 小顶堆中结点更可能移动到左右子节点中更小的那边
		if (right < this.size) {
			tmp = this.compareItems(this.heap[left], this.heap[right]) ? right : left;
		} else tmp = left;  // 如果没有右边的节点

		// 以下代码确认当前结点是否要移动到tmp位置
		if (this.compareItems(this.heap[pos], this.heap[tmp])) {
			[this.heap[pos], this.heap[temp]] = [this.heap[tmp], this.heap[pos]];
			pos = tmp;
			left = this.leftChild(pos);
			right = this.rightChild(pos);
		} else break;  // 不能移动到tmp，则退出
	}
}
```
删除指定位置`pos`结点：
```js
remove(pos) {
	if (pos < this.size) {
		let last = this.getLast();
		let delNode = this.heap[pos];
		this.size--;

		// 如果pos是末尾结点，直接size--
		if (pos < this.size) {
			this.heap[pos] = last;
			this.heapifyDown(pos);
		}
		return delNode;
	}
}
```
其中`getLast()`为：
```js
getLast() {
	return this.size > 0 ? this.heap[this.size - 1] : undefined;
}
```
插入结点：
```js
insert(val) {
	let pos = this.size++;  // 增加堆节点数
	this.heap[pos] = val;  // 新节点
	this.heapifyUp(pos);  // 回到应有的位置
}
```
以下摘自[【基础算法】详解堆+面试快速手写堆代码 | Hu's Notes (hukeyi.github.io)](https://hukeyi.github.io/posts/basic-heap-js/)：
```js
class Heap {
	constructor(func) {
		this.h = [];
		this.size = 0;
		this.func = func;
	}

	comp(a, b) {
		return this.func(this.h[a], this.h[b]) > 0;
	}

	swap(a, b) {
		[this.h[a], this.h[b]] = [this.h[b], this.h[a]];
	}

	left(p) {
		return p * 2 + 1;
	}

	right(p) {
		return p * 2 + 2;
	}

	parent(p) {
		return (p - 1) >> 1;
	}

	isLeaf(p) {
		return p >= this.size >> 1 && p < this.size;
	}

	// 上浮
	swim(p) {
		let parent = this.parent(p);
		while (p > 0 && this.comp(parent, p)) {
			this.swap(p, parent);
			p = parent;
			parent = this.parent(p);
		}
	}

	// 下沉
	sink(p) {
		while (!this.isLeaf(p)) {
			let l = this.left(p),
				r = this.right(p),
				next = l;
			if (r < this.size && this.comp(next, r)) next = r;

			if (this.comp(p, next)) {
				this.swap(next, p);
				p = next;
			} else break;
		}
	}

	insert(val) {
		this.h[this.size++] = val;
		this.swim(this.size - 1);
	}

	removeTop() {
		let top = this.h[0];
		this.swap(0, this.size - 1);
		this.size--;
		if (this.size > 0) this.sink(0);
		return top;
	}
}
```
## 散列表(Hash)
散列表，也称作哈希表，是根据键(Key)而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数（散列函数），将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。[![散列表.png](https://www.freeimg.cn/i/2024/04/09/661531601d9cd.png)](https://www.freeimg.cn/i/2024/04/09/661531601d9cd.png)
### 散列表的构成
散列表的组成分为以下这几个部分：
- M个槽
- 散列函数(hash函数)
- add方法添加键值到散列表中
- delete方法删除指定键值
- search方法根据key寻找指定的值
让我们先简单初始化一个散列表：
```js
class HashTable {
	constructor(num = 1000) {
		this.M = num;  // 1000 个槽位
		this.slots = new Array(num);  // 槽位内的多个存储空间
	}
}
```
### 散列函数
处理字符串的散列函数：
```js
h(str) {
	str = str + '';
	return [...str].reduce((hash, c) => {
		hash = (331 * hash + c.charCodeAt()) % this.M;
		return hash;
	}, 0);
}
```
### 功能函数
添加键值对：
```js
add(key, value) {
	const h = this.h(key);
	// 判断这个槽是否是一个二维数组，不是则创建二维数组
	if (!this.slots[h]) {
		this.slots[h] = [];
	}
	const o = new Object({key, value});
	// 将值添加到对应的槽中
	this.slots[h].push(o);
}
```
删除键值对：
```js
delete(key) {
	const h = this.h(key);
	this.slots[h] = this.slots[h].filter(item => item.key !== key);
}
```
查找对应的值：
```js
search(key) {
	const h = this.h(key);
	const list = this.slots[h];
	const data = list.find(x => x.key === key);
	return data ? data.value : null;
}
```
## 树（DFS和BFS）
树，是一种使用节点来模拟分等级（层次）数据的数据结构。节点存储数据，并指向其他节点（每个节点都存储有自身数据，和指向其它节点的指针）。两种遍历方式：`DFS`和`BFS`，分别是`Depth-First-Search`深度优先搜索，`Breadth-First-Search`宽度优先搜索。[![BFS_DFS.png](https://www.freeimg.cn/i/2024/04/15/661ced32929d1.png)](https://www.freeimg.cn/i/2024/04/15/661ced32929d1.png)
树有以下几个特点：
- 每个节点都只有有限个子节点或无子节点
- 没有父节点的节点称为根节点
- 每一个非根节点有且只有一个父节点
- 除了根节点外，每个子节点可以分为多个不相交的子树
- 树里面没有环路
### 树的种类
树的种类分为以下几种：
- **二叉树**：每个节点最多含有两个子树的树
	- 完全二叉树：除了最后一层外，每一层的节点都是满的，且最后一层的节点都尽可能地靠左排列
	- 满二叉树：除了叶子节点外，每个节点都有两个子节点
	- 二叉查找树：每个节点的值都大于其左子树中的值，小于其右子树中的值
- **霍夫曼树**：一种用于数据压缩的树结构，根据字符出现的频率构建树，频率越高的字符离根节点越近
- **字典树**：用于存储关联数组的树形数据结构，适用于字符串键值的快速查找、插入和删除
- **红黑树**：一种自平衡的二叉搜索树，具有较为严格的平衡性质，用于实现高效的插入、删除和查找操作
- **线段树**：一种用于解决区间查询问题的树形数据结构，通常用于处理一维数组的区间查询、更新等操作
- **AVL树**：一种自平衡的二叉搜索树，通过旋转操作保持树的平衡，具有较为严格的平衡性质，通常用于实现高效的插入、删除和查找操作
- **B树/B+树**：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树，常用于数据库和文件系统中
- **树堆(Heap)**：一种特殊的树结构，通常用数组实现，常见的有二叉堆和 Fibonacci 堆，用于实现优先队列等数据结构
#### 二叉树的实现
先定义一个节点`Node`的类：
```js
class Node {
  constructor(data) {
      this.data = data;  // 数据
      this.parent = null;  // 父节点
      this.children = [];  // 子节点
  }
}
```
再定义一个树`Tree`的类：
```js
class Tree {
	constructor(data) {
	    let node = new Node(data);  // 创建新节点
	    this._root = node;  // 赋值根节点
  }
}
```
##### 操作方法
`find(data)`方法，该方法使用深度优先搜索（DFS），`find`将递归的向下获取到树的叶节点，然后向上返回：
```js
// 寻找某个节点 (DFS)
find(data, node = this._root) {
// 如果当前节点匹配
if (node.data === data) {
  return node;
}
// 遍历子节点
for (let child of node.children) {
  // 对于子树
  if (this.find(data, child)) {
	return child;
  }
}
// 找不到对应的数据
return null;
}
```
`add(data, parentData)`添加元素到指定的父节点：
```js
add(data, parentData) {
	let node = new Node(data);
	let parent = this.find(parentData);
    // 如果父节点存在，就添加节点
    if (parent) {
      parent.children.push(node);
      node.parent = parent;
      // 返回节点
      return node;
    } else {
      throw new Error(`Cannot add node: parent with data ${parentData} not found`);
    }
}
```
`remove(data)`删除指定节点：
```js
remove(data) {
	let node = this.find(data);
	if (node) {
	  // 返回被删除节点的父节点parent
	  let parent = node.parent;
	  let indexOfNode = parent.children.indexOf(node);
	  // 从父节点里删除 splice(要删除元素的索引，要删除元素的数量)
	  parent.children.splice(indexOfNode, 1);
	} else {
	  throw new Error(`Cannot remove node: node with data ${data} not found`);
	}
}
```
`forEach(callback, node = this._root)`深度优先搜索遍历（DFS）：
```js
forEach(callback, node = this._root) {
	// 遍历每个子节点
	for (let child of node.children) {
	  this.forEach(callback, child);
	}
	// 数据找不到
	callback(node);
}
```
`forEachBreadthFirst(callback)`广度优先搜索遍历（BFS）：
```js
forEachBreadthFirst(callback) {
	// 从根节点开始
	let queue = [];
	queue.push(this._root);
	while (queue.length > 0) {
	  let node = queue.shift();
	  callback(node);
	  // 将子节点推入队列
	  for (let child of node.children) {
		queue.push(child);
	  }
	}
}
```
测试用例：
```js
let t = new Tree("CEO");
t.add("VP Finance", "CEO");
t.add("VP Sales", "CEO");
t.add("Salesperson", "VP Sales");
t.add("Accountant", "VP Finance");
t.add("Bookkeeper", "VP Finance");
// 深度优先搜索
t.forEach((node) => console.log(node.data));
console.log('==========');
// 广度优先搜索
t.forEachBreadthFirst(node => console.log(node.data));
console.log(t.find("Bookkeeper"));  // 展示对应节点
t.remove("VP Finance");
console.log(t.find("Bookkeeper"));  // null
```
#### 霍夫曼树
霍夫曼树（最优树），也称作哈夫曼树，是带权路径长度（WPL）最短的树，带权路径长度为从根节点到该节点之间的路径长度与节点上权的乘积之和。
构成霍夫曼树的步骤：
1. 从小到大排序，将每一个节点看成一颗最简二叉树
2. 取出根节点权值最小的两颗二叉树
3. 组成一颗新的二叉树，该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和
4. 再将这颗新的二叉树，以根节点的权值大小再次排序，不断重复1-2-3-4的步骤，直到数列中所有的数据都被处理
##### 霍夫曼树的实现
我们先创建一个节点类`Node`：
```js
class Node {
	constructor(value, char, left, right) {
		this.value = value;
		this.char = char;
		this.left = left;
		this.right = right;
	}
}
```
然后再定义霍夫曼树`HuffmanTree`的类：
```js
// 霍夫曼编码是将一个字符串序列用二进制表示的压缩算法
class HuffmanTree {
	constructor(str) {
		// 统计字符出现频率
		let hash = {};
		for (let i = 0; i < str.length; i++) {
			// ~~表示将undefined类型转换为0
			hash[str[i]] = ~~hash[str[i]] + 1;
		}
		this.hash = hash;

		// 构造霍夫曼树
		this.huffmanTree = this.getHuffmanTree();

		let map = this.getHuffmanCode(this.huffmanTree);
		// 查看对照表，即每个字符对应的二进制编码
		console.log(map);

		// 最终的二进制编码
		this.binaryStr = this.getBinaryStr(map, str);
	}

	// 构造霍夫曼树
	getHuffmanTree() {
		// 以各个字符出现次数为node.value,构造森林
		let forest = [];
		for (let char in this.hash) {
			let node = new Node(this.hash[char], char);
			forest.push(node);
		}

		// 等到森林只有一个节点，表示合并过程结束
		let allNodes = [];
		while (forest.length !== 1) {
			// 从森林中找到两个最小的数，并且合并(sort改变原数组)
			forest.sort((a, b) => {
				return a.value - b.value;
			});

			let node = new Node(forest[0].value + forest[1].value, "");
			allNodes.push(forest[0]);
			allNodes.push(forest[1]);
			// 左子树放置低词频
			node.left = allNodes[allNodes.length - 2];
			// 右子树放置高词频
			node.right = allNodes[allNodes.length - 1];

			// 删除最小的两颗树
			forest = forest.slice(2);
			// 新增树的加入
			forest.push(node);
		}

		// 生成的霍夫曼树
		return forest[0];
	}

	// 遍历霍夫曼树， 返回一个原始字符和二进制编码的对照表
	getHuffmanCode(tree) {
		let hash = {};  // 对照表
		let traversal = (node, curPath) => {
			// 没有左子树也没有右子树
			if (!node.length && !node.right) return;
			// 有左子叶
			if (node.left && !node.left.left && !node.left.right) {
				hash[node.left.char] = curPath + "0";
			}
			// 有右子叶
			if (node.right && !node.right.left && !node.right.right) {
				hash[node.right.char] = curPath + "1";
			}
			// 往左遍历，路径加0
			if (node.left) {
				traversal(node.left, curPath + "0");
			}
			// 往右遍历，路径加1
			if (node.right) {
				traversal(node.right, curPath + "1");
			}
		};
		// 遍历霍夫曼树
		traversal(tree, "");
		return hash;
	}

	// 返回最终的压缩后的二进制串
	getBinaryStr(map, originStr) {
		let result = "";
		for (let i = 0; i < originStr.length; i++) {
			result += map[originStr[i]];
		}
		return result;
	}
}
```
##### 测试结果
```js
let tree = new huffmanTree("ABBCCCDDDDEEEEE");
console.log(tree);

// { C: '00', A: '010', B: '011', D: '10', E: '11' }
// binaryStr: '010011011000000101010101111111111'
```
#### 字典树
字典树，是一种**空间换时间**的数据结构，又称为Trie树、前缀树，一般用于统计、排序和保存大量字符串，经常被用于搜索引擎的文本词频统计。优点：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。
字典树三个重要性质：
1. 根节点不包含字符，除了根节点每个节点都只包含一个字符。root节点不含字符
2. 从根节点到某一个节点，路过字符串起来就是该节点对应的字符串
3. 每个节点的子节点字符不同，字符是唯一的
##### 字典树(Trie)的实现
先定义一个节点：
```js
class Node {
	constructor(value) {
		this.value = value;
		this.isWord = false;
		this.children = {};
	}
}
```
再创建一个字典树(Trie)的类：
```js
class Trie {
	constructor() {
		// 根节点不需要值
		this.root = new Node();
	}
}
```
插入方法`insert(word)`：
```js
insert(word) {
	let curNode = this.root;  // 获取当前节点
	let arr = word.split('');  // 拆分单词
	for(let i = 0; i < arr.length; i++) {
		// 获取子节点
		let isHasChildNode = curNode.children[arr[i]];
		// 如果没有子节点，就创建一个以当前字符为value的子节点
		if(!isHasChildNode) {
			curNode.children[arr[i]] = new Node(arr[i]);
		}
		// 切换当前节点为新创建/已存在的节点
		curNode = curNode.children[arr[i]];

		// 遍历到最后一个字符所对应的节点，将该节点的isWord的属性设置为true
		if(i === arr.length - 1) {
			curNode.isWord = true;
		}
	}
}
```
查询方法`search(word)`：
```js
search(word) {
	// 将根节点设置为当前节点
	let curNode = this.root;
	let arr = word.split('');

	for(let i = 0; i < arr.length; i++) {
		// 如果节点不存在返回false
		if(!curNode.children[arr[i]]) {
			return false;
		}
		curNode = curNode.children[arr[i]];

		// 如果搜索到最后一个字符，就根据isWord进行判断
		if(i === arr.length - 1) {
			return curNode.isWord;
		}
	}
}
```
前缀补全查询方法`startsWith`：
```js
startsWith(prefix) {
	let curNode = this.root;
	let arr = prefix.split('');
	for(let i = 0; i < arr.length; i++) {
		// 凡是查找的单词的中间某个字符缺少，就返回false
		if(!curNode.children[arr[i]]) {
			return false;
		}
		curNode = curNode.children[arr[i]];
	}
	// 每个字符都找到了节点则返回true
	return true;
}
```
##### 测试结果
```js
let trie = new Trie();
trie.insert("Lemon");
console.log(trie.search("Lemon"));  // true
console.log(trie.search("Le"));  // false
console.log(trie.startsWith("Le"));  // true
```
#### AVL树
AVL树，又称为平衡二叉树